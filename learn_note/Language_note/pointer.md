pointer
====


指针的使用出错，一般就是segment fault。

###分析原因

* 没有分配内存空间
* 没有指向，但却使用这个指针

###指针

我们常常看得的定义为int *p; 这是一个整型指针，没有指向任何地方。下面是用int a; p = &a;这就表明p指向了a的地址
。此时*p就代表的是a的值。如果此时在定义一个int **q;q = &p;此时这个q就是指向了p的地址，此时**py也是等于a的。我们可以看到*(&p)=p,
也就和一些定义得意思相符合了。

###字符指针

我们一般有两种方式定义字符串，一个是使用字符数组。如char a[] = "hello world"。我们同样可以这样定义char *a = "hello world"。


###char型二级指针

我们在定义一组字符串的时候，我们习惯性定义为char **value.这样的定义在某些情况下我们可以理解为*value[],正如main函数的参数一样，这是一个二级指针，value[xx]就代表的是这个字符串。但是我们在使用char **value的时候需要为这个value分配空间。此时我们需要先为value先申请一个空间，

value = (char **)malloc(sizeof(char *) * length),因为value的类型是指向指针的指针。所以类型是char *,这只是为value分配了空间。但是如果我们此时使用value[1] = "hello"这样的用法的话，一般就会报错segment fault。

为什么会报错，我们此时只是为value本身分配了内存空间，但是对于value指向的char *没有分配空间。也就是没有为字符串分配空间。所以还要再次分配一下
空间。value[i] = (char *)malloc(sizeof(char) * maxlen); 这样这个二级指针在字符串赋值的时候就不会报错了。



###指针传参
我们有时候在写一些函数的时候，我们可以使用返回值来实现对一个结构体或是一个链表的赋值，但是有时我们直接使用指针作为参数，将结构体或是链表的地址传过去，达到一种修改的目的。有时候我们使用二级指针来实现更改，这在一个数据结构中使用的比较多。



