使用protobuf-c
====

###.proto文件

一切的序列化消息基于.proto文件的定义，三个字段，required/optional/repeated。
官方的介绍相当的官方，在具体的编程中，基本是感受不出的。总结下这个三个标志的在编程中的用处是

* required  算是必备字段，但是有时会捣乱，在生成的.h文件中，所定义的字段在结构体中和c语言定义的没有差别，int32变成 int32_t。
string变成char *，很好理解。

* optional 从字面上看可以知道这是一个可选的意思。也就是说，定义出的字段不一定要被赋值，通过一个has_xxx的标志进行判断。其他和required相似
* repeated 字面意思是重复。在编译好的.h文件中，它所定义的字段是一个二级指针。可以保存多个值


###enum

枚举类型是一个比较灵活的，可以嵌套着定义在message中，也可单独定义。只是在编译后.h中名称差别。所以使用的时候需要注意区分。


###使用在C中

* 在编译的时候加-lprotobuf-c
* 在初始化的时可以调用宏来初始化。也可以使用生成的函数。效果一样
* 需要先获取到消息的长度，直接调用函数，然后分配buf的空间。接着打包。
* 在有repeated定义的二级指针的情况下，需要注意内存的分配。
* 嵌套定义的message。通常是通过直接赋值的方式赋值给主message。

###encoding

了解protobuf是如何encoding我们的数据的，一般我们定义的时候有一个tag标志，也就是1，2，3等等这些tag在encoding的时候也被算进去了。如果我们定义一个requried int32 a=1。我们赋给a的值是150，我们能得到的序列化数为08 96 01 如何得到150呢？

先看8，二进制为0000 1000 我们去掉最高标志位（msb）000 1000.然后右移3位得到1，这就是那个tag，我们在对后面的96和01将其换成二进制。得到
1001 0110 0000 0001，同样及那个每个输得msb位去掉得打001 0110 000 0001 接着我们组合一下，变成1001 0110 将1放在前面。然后我们计算下这个二进制128+16+4+2=150. 也就是这个encoding是这样完成的。

这边只是一部分的encoding，具体的可以参见官网给出的encoding解释。[encoding](https://developers.google.com/protocol-buffers/docs/encoding)



